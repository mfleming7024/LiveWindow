<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Fog Overlay</title>
    <style>
        /* Basic reset and body styling */
        body {
            margin: 0;
            overflow: hidden;
            color: white;
        }

        /* The canvas for the Three.js scene */
        #fog-canvas {
            position: fixed;
            top: 0;
            left: 0;
			opacity: 0.4; /* Slightly transparent to blend with the background */
            width: 100%;
            height: 100%;
            z-index: 1; /* Sits on top of the background */
        }
    </style>
</head>
<body>

    <!-- The canvas where the fog effect will be rendered -->
    <canvas id="fog-canvas"></canvas>

    <!-- Import Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- Three.js Scene Setup ---

        let scene, camera, renderer, clock, fogMesh;

        // --- Shaders ---
        // These are small programs that run on the GPU.
        // The vertex shader positions the vertices of the geometry.
        // The fragment shader colors each pixel (fragment).

        const vertexShader = `
            // Varyings are variables passed from the vertex shader to the fragment shader.
            varying vec2 vUv; 
            void main() {
                // vUv is the UV coordinate of the vertex.
                vUv = uv; 
                // gl_Position is a special variable that holds the final position of the vertex.
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            // Variables passed in from our JavaScript code (uniforms) and from the vertex shader (varyings).
            varying vec2 vUv;
            uniform float u_time;
            uniform vec3 u_fogColor;
            
            // 2D Random function by Morgan McGuire @morgan3d
            // https://www.shadertoy.com/view/4dS3Wd
            float random (in vec2 st) {
                return fract(sin(dot(st.xy,
                                     vec2(12.9898,78.233)))
                             * 43758.5453123);
            }

            // 2D Noise based on Morgan McGuire's random function
            float noise (in vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);

                // Four corners in 2D of a tile
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));

                // Smoothly interpolate between the corners
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) +
                        (c - a)* u.y * (1.0 - u.x) +
                        (d - b) * u.x * u.y;
            }

            void main() {
                // We create three layers of noise to simulate fog with more depth.
                // By moving them at different speeds, we create a parallax effect.

                // Layer 1: Distant, slow-moving, large-scale fog
                vec2 uv1 = vUv * 1.5; 
                uv1.x += u_time * 0.01; 
                float noise1 = noise(uv1);

                // Layer 2: Mid-ground fog
                vec2 uv2 = vUv * 4.0;
                uv2.x += u_time * 0.04;
                float noise2 = noise(uv2);

                // Layer 3: Foreground, faster-moving, detailed fog
                vec2 uv3 = vUv * 8.0;
                uv3.x += u_time * 0.07;
                float noise3 = noise(uv3);
                
                // Combine the noise layers for a richer texture.
                float combinedNoise = noise1 * 0.4 + noise2 * 0.3 + noise3 * 0.3;

                // Use smoothstep to create the "wisps" of fog from the combined noise.
                float wispAmount = smoothstep(0.2, 0.6, combinedNoise);

                // Create the vertical gradient for the fog.
                // It should be opaque at the bottom (vUv.y = 0) and fade out towards the 40% mark (vUv.y = 0.4).
                // smoothstep(edge0, edge1, x) transitions from 0 to 1 as x goes from edge0 to edge1.
                // By reversing the edges (0.4, 0.2), we get a value that goes from 1 to 0 as vUv.y goes from 0.2 to 0.4.
                float verticalFade = smoothstep(0.4, 0.2, vUv.y);

                // The final alpha is the wispiness multiplied by the vertical fade and a general opacity control.
                float finalAlpha = wispAmount * verticalFade * 0.9;

                // The final color is the fog color, with the alpha determined by our calculations.
                gl_FragColor = vec4(u_fogColor, finalAlpha);
            }
        `;

        function init() {
            // --- Basic setup ---
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            
            // --- Camera ---
            // An orthographic camera is used here because we are rendering a 2D plane
            // and don't need perspective.
            camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            // --- Renderer ---
            const canvas = document.getElementById('fog-canvas');
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true // Make the canvas transparent
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            // --- Fog Geometry and Material ---
            // A simple plane that will cover the entire screen.
            const fogGeometry = new THREE.PlaneBufferGeometry(2, 2);

            // The shader material uses our custom vertex and fragment shaders.
            const fogMaterial = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    // u_time will be updated every frame to animate the fog.
                    u_time: { value: 0.0 },
                    // u_fogColor defines the color of the fog.
                    u_fogColor: { value: new THREE.Color(0.8, 0.85, 0.9) }
                },
                transparent: true // The material needs to be transparent.
            });

            // --- Fog Mesh ---
            // We create a mesh with our geometry and material and add it to the scene.
            fogMesh = new THREE.Mesh(fogGeometry, fogMaterial);
            scene.add(fogMesh);

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize, false);

            // --- Start Animation ---
            animate();
        }

        // --- Handle window resizing ---
        function onWindowResize() {
            // Update camera and renderer size
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Animation Loop ---
        function animate() {
            // Request the next frame
            requestAnimationFrame(animate);

            // Update the time uniform in the shader material
            fogMesh.material.uniforms.u_time.value = clock.getElapsedTime();

            // Render the scene
            renderer.render(scene, camera);
        }

        // --- Initialize the scene on window load ---
        window.onload = init;

    </script>
</body>
</html>
